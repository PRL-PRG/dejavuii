---
title: "Analysis of folder clones"
output: html_notebook
---
 
This contains analysis of project and folder clones, full & partial. 

# Questions

1) do we want to exclude stuff from the datasets? such as intraproject, etc. YES 

```{r,echo=F}
DROOT = "/data/dejavu/no-npm"
source("helpers.R")
loadProjects()
```


```{r}
originals = readDataset("folderCloneOriginals.csv")
clones = readDataset("folderCloneOccurences.csv")
```
# Intra Project Clones

First we remove intra project clones from the datasets as these are not really interesting for us:

```{r}
x = originals %>% select(cloneId, originalProjectId = projectId)
x = inner_join(clones, x, by = "cloneId")
intraClones = x %>% filter(projectId == originalProjectId) %>% select(-originalProjectId)
xclones = x %>% filter(projectId != originalProjectId) %>% select(-originalProjectId)
intraOriginals = originals %>% filter(! (cloneId %in% xclones$cloneId))
xoriginals = originals %>% filter(cloneId %in% xclones$cloneId)
LOG("Intra clones", d = nrow(intraClones), pct = nrow(clones))
LOG("Intra-only originals", d = nrow(intraOriginals), pct = nrow(originals))
```

This is interesting. `51%` of the originals we have are intra-project originals only, i.e. their clones only appear in the same project. These are most likely artefacts from copying, etc. and we can safely remove them from the dataset. 

```{r}
clones = xclones
originals = xoriginals
rm(xclones)
rm(xoriginals)
```

This is how the dataset looks like now:

```{r}
LOG("Original records", d = nrow(originals))
LOG("Clone records", d = nrow(clones))
```

> Do we want some extra analysis of intra-project clones & originals? 

# Project Clones & Originals

First we take part of the dataset which deals with projects. That is all originals where the path is empty (i.e. the whole project is cloned) and then all clones of these originals:

```{r}
projectOriginalsRecords = originals %>% filter(is.na(path))
projectClonesRecords = clones %>% filter(cloneId %in% projectOriginalsRecords$cloneId)
LOG("Originals records", d = nrow(projectOriginals), pct = nrow(originals))
LOG("Clones records", d = nrow(projectClones), pct = nrow(clones))
```

Let's see how much of the dataset in terms of projects this is:

```{r}
projectOriginals = projectOriginalsRecords %>% group_by(projectId) %>% summarize(clones = n())
projectClones = projectClonesRecords %>% group_by(projectId) %>% summarize(sources = n())
LOG("Projects which are originals", d = nrow(projectOriginals), pct = numProjects())
LOG("Projects which contain clones", d = nrow(projectClones), pct = numProjects())
```

How many projects are both originals and contain clones of other projects?

```{r}
x = inner_join(projectOriginals, projectClones, by = "projectId")
LOG("Project being both originals and containing clones", d = nrow(x), pct = nrow(projectOriginals))
```

`14%` of the projects which are originals also contain clones of entire other projects in them.

> This is a bit high, perhaps we should investigate?

## How are projects being cloned?

Project can either be cloned into a root folder of other project (akin to fork), or to a folder in a project (submodule). First, what is the percentage of the root-to-root clones?

```{r}
LOG("Project root clones (records)", d = nrow(projectClonesRecords %>% filter(is.na(path))), pct = nrow(projectClonesRecords))
LOG("Unique projects which cloned other project in their root", d = nrow(projectClonesRecords %>% filter(is.na(path)) %>% group_by(projectId) %>% summarize(count = n())), pct = numProjects())
```

Ok, so `5.4%` of the projects we have are essentially forks of other projects, which is some 170k projects in total. Interesting is the small discrepancy between the number of records and number of unique projects - given our definition of folder clones, that means these projects had to have all their javascript files deleted from them and then a project had to be copied again. Let's look at them:

```{r}
x = projectClonesRecords %>% filter(is.na(path)) %>% group_by(projectId) %>% summarize(count = n()) %>% filter(count > 1)
summary(x$count)
DT::datatable(x %>% arrange(desc(count)) %>% head(100))
```

> TODO look at the ones above manually

Where are the project copied then? 

```{r}
x = projectClonesRecords %>% group_by(path) %>% summarize(count = n(), files = mean(files))
DT::datatable(x %>% arrange(desc(count)) %>% head(100))
```
This looks nice - what we see here is a clear pattern that submodules should have been used really. 


Some of these might want extra attention, copying 2 files from 27331 seems a bit too much;-D

# Folder Clones

Now let's concentrate on those originals where the original is a folder, i.e. not an entire project:


# Clones Behavior

```{r}
cloneBehavior = readDataset("folderCloneOccurencesBehavior.csv")
```

Ok, now remove the intra project clones. 

```{r}
x = originals %>% select(cloneId, originalProjectId = projectId)
x = inner_join(cloneBehavior, x, by = "cloneId")
cloneBehavior = x %>% filter(projectId != originalProjectId) %>% select(-originalProjectId)
LOG("Clone Behavior records", d = nrow(cloneBehavior), pct = nrow(clones))
```

Now let's do some analysis:

```{r}
summary(cloneBehavior$changingCommits)
summary(cloneBehavior$divergentCommits)
summary(cloneBehavior$syncCommits)
summary(cloneBehavior$syncDelay)
summary(cloneBehavior$fullySyncedTime)
```








# OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD 
# OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD 
# OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD OLD 



peta@prl1e:~/devel/dejavuii/build$ time ./dejavu filter-folder-clones -d=/data/dejavu/no-npm -o=/data/dejavu/no-folder-clones -filter=/data/dejavu/no-npm/folderCloneOccurences.csv -n=40
OH HAI CAN I HAZ DEJAVU AGAINZ?
Loading projects ...
Loading commits ...
Loading commit parents ...
Loading paths ...
Loading file changes ...
Filtering file changes...
Writing clone change sizes...
Writing filtered projects...
    3024039 projects written
    3186352 projects total
Removing empty commits...
    7350336 commits detached
    61897259 out of total
Writing filtered commits...
Writing commit parents...
Creating symlinks...
ln: failed to create symbolic link '/data/dejavu/no-folder-clones/hashes.csv': File exists
ln: failed to create symbolic link '/data/dejavu/no-folder-clones/paths.csv': File exists
KTHXBYE!
real    78m45.054s
user    365m8.195s
sys     33m26.582s                        

Let's do some summaries:

```{r}
LOG("Total originals", d = nrow(originals))
LOG("Total clones", d = nrow(clones))
```

```{r}
summary(originals$occurences);
summary(originals$files);
```

Actually, how much of this is interproject? 

```{r}
x = inner_join(clones %>% select(cloneId, cloneProject = projectId), originals %>% select(cloneId, originalProject = projectId))
intrax = x %>% filter(cloneProject == originalProject)
LOG("Intra-project clones: ", d = nrow(intrax), pct = nrow(x))
```
ok, not too bad. 

```{r}
x = originals %>% select(occurences)
h = hist(x$occurences, breaks = 100, plot = F)
h$counts =log10(h$counts + 1)
plot(h, ylab="log10(# of packages)", xlab = "# of times the package is included", main = "How often is a package included")
```

```{r}
#plot(log10(originals$files), log10(originals$occurences))
# Change point shapes by the levels of cyl
ggplot(originals %>% sample_n(100000), aes(x=log10(files), y=log10(occurences), color=isOriginalClone)) +
  geom_point()
```


# Originals being clones 

Some of the originals are themselves a clone. These are perhaps less likely to be interesting. 

```{r}
LOG("Originals which are clones", d = sum(originals$isOriginalClone), pct = nrow(originals))
```

```{r}
originalsClones = originals %>% filter(isOriginalClone == 1) %>% group_by(path) %>% summarize(numOriginals = n(), numClones = sum(occurences), files = mean(files))
DT::datatable(originalsClones %>% arrange(desc(numOriginals)) %>% head(100))
```
So interestingly, the largest section is entire projects which are themselves clones, both in number of originals and in number of clones. The file numbers are non-trivial in the most cloned files. The paths appear to be reasonable, i.e. they are short and names that we woudl actually expect to see copied. 

> Manually, we should check some of these. 

Let's see the summary of the number of originals and number of clones:

```{r}
summary(originalsClones$numOriginals)
summary(originalsClones$numClones)
```

And most of them seem to be degenerate,m i.e. very very small number of clones and originals.


# Project Clones

 Let's see first, how many of the originals are entire projects, which we do by celecting those with empty path:
 
```{r}
projectOriginals = originals %>% filter(is.na(path))
projectClones = clones %>% filter(cloneId %in% projectOriginals$cloneId)
LOG("Project originals", d = nrow(projectOriginals), pct = nrow(originals))
LOG("Project clones", d = nrow(projectClones), pct = nrow(clones))
```

```{r}
x = projectOriginals %>% group_by(projectId) %>% summarize(count = n())
nrow(x)
y = projectClones %>% group_by(projectId) %>% summarize(count = n())
nrow(y)
```
```{r}
x = originals %>% group_by(projectId) %>% summarize(count = n())
nrow(x)
y = clones %>% group_by(projectId) %>% summarize(count = n())
nrow(y)
```


How many of these are clones from root folder to root folder? 

```{r}
LOG("Project root clones (forks)", d = nrow(projectClones %>% filter(is.na(path))), pct = nrow(projectClones))
```

Where are the project copied? 
 
```{r}
x = projectClones %>% group_by(path) %>% summarize(count = n(), files = mean(files))
DT::datatable(x %>% arrange(desc(count)) %>% head(100))

```
 This looks actually fairly reasonable to me - by far the largest is when projects are copied to projects, that is what we should have expected from above. The other paths to which whole projects are copied very nicely hints at submodules would have been great, but apparently people did not bother. 
 
